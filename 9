#include <reg51.h>

// Motor control pins (connected to L293D inputs)
sbit motor_pin1 = P1^0;
sbit motor_pin2 = P1^1;

// Button for reversing direction
sbit button_reverse = P2^0;

bit motor_direction = 0; // Flag to track direction

// Standard delay
void delay(unsigned int time) {
    unsigned int i, j;
    for(i = 0; i < time; i++) {
        for(j = 0; j < 1275; j++);
    }
}

// A much longer delay for PWM
void low_speed_delay(unsigned int time) {
    unsigned int i, j;
    for(i = 0; i < time; i++) {
        for(j = 0; j < 100000; j++); // Significantly larger loop
    }
}

void main() {
    // Initial motor direction: (1, 0) -> e.g., Clockwise
    motor_pin1 = 1;
    motor_pin2 = 0;
    
    while(1) {
        // --- Direction Control Logic ---
        if(button_reverse == 0) { // Check if button is pressed (active-low)
            delay(50); // Simple debounce delay
            while(button_reverse == 0); // Wait for button to be released
            
            motor_direction = !motor_direction; // Toggle the direction flag
            
            if(motor_direction == 1) {
                motor_pin1 = 0; // Set direction to (0, 1) -> Counter-Clockwise
                motor_pin2 = 1;
            } else {
                motor_pin1 = 1; // Set direction to (1, 0) -> Clockwise
                motor_pin2 = 0;
            }
            delay(50); // Another debounce delay
        }
        
        // --- Speed Control (PWM) Logic ---
        // This part runs regardless of the button press, but the direction
        // (set by the logic above) is maintained.
        
        // This code is problematic. It tries to set (1,0) then (0,0)
        // This will override the direction set by the button.
        
        /* * --- Original Code's (flawed) PWM Logic ---
         * motor_pin1 = 1;
         * motor_pin2 = 0;
         * low_speed_delay(10); // Motor ON for a long time
         * motor_pin1 = 0;
         * motor_pin2 = 0; // Motor OFF (Brake)
         * low_speed_delay(10); // OFF delay
         */
         
         // --- A Corrected PWM Logic would be: ---
         // (Assuming motor_pin1 and motor_pin2 hold the correct direction)
         
         // 1. Keep the current direction, but pulse the motor ON
         // (This requires an 'Enable' pin, which isn't defined, 
         // so we'll pulse the pins themselves)
         
         if (motor_direction == 1) { // CCW
             motor_pin1 = 0; motor_pin2 = 1;
         } else { // CW
             motor_pin1 = 1; motor_pin2 = 0;
         }
         low_speed_delay(10); // --- Motor ON Period ---
         
         // 2. Turn motor OFF (Brake)
         motor_pin1 = 0;
         motor_pin2 = 0;
         low_speed_delay(10); // --- Motor OFF Period ---
    }
}
